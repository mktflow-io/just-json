package io.mktflow.json.processor;

import io.mktflow.json.JsonRecord;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ArrayType;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

@SupportedAnnotationTypes("io.mktflow.json.JsonRecord")
@SupportedSourceVersion(SourceVersion.RELEASE_25)
public class JsonRecordProcessor extends AbstractProcessor {

    private final List<String> adapterClassNames = new ArrayList<>();
    private boolean registryGenerated = false;

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        var annotatedElements = roundEnv.getElementsAnnotatedWith(JsonRecord.class);

        for (Element element : annotatedElements) {
            if (!(element instanceof TypeElement typeElement)) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                        "@JsonRecord can only be applied to records", element);
                continue;
            }
            if (typeElement.getRecordComponents().isEmpty() && typeElement.getKind().toString().equals("CLASS")) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                        "@JsonRecord can only be applied to records", element);
                continue;
            }
            generateAdapter(typeElement);
        }

        // Generate registry in the same round as adapters (not in processingOver)
        // so the generated source file participates in compilation
        if (!registryGenerated && !adapterClassNames.isEmpty() && !annotatedElements.isEmpty()) {
            generateRegistry();
            registryGenerated = true;
        }

        return true;
    }

    private void generateAdapter(TypeElement recordElement) {
        String packageName = processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();
        String recordSimpleName = recordElement.getSimpleName().toString();
        String adapterSimpleName = recordSimpleName + "JsonAdapter";
        String adapterQualifiedName = packageName.isEmpty() ? adapterSimpleName : packageName + "." + adapterSimpleName;

        adapterClassNames.add(adapterQualifiedName);

        List<? extends RecordComponentElement> components = recordElement.getRecordComponents();

        try {
            JavaFileObject file = processingEnv.getFiler().createSourceFile(adapterQualifiedName, recordElement);
            try (var out = new PrintWriter(file.openWriter())) {
                if (!packageName.isEmpty()) {
                    out.println("package " + packageName + ";");
                    out.println();
                }

                out.println("import io.mktflow.json.Json;");
                out.println("import io.mktflow.json.internal.JsonMapper;");
                out.println("import io.mktflow.json.internal.JsonValue;");
                out.println("import io.mktflow.json.internal.JsonWriter;");
                out.println();
                out.println("/**");
                out.println(" * Generated JSON adapter for {@link " + recordSimpleName + "}.");
                out.println(" * Do not modify — regenerated by the annotation processor.");
                out.println(" */");
                out.println("final class " + adapterSimpleName + " {");
                out.println();
                out.println("    private " + adapterSimpleName + "() {}");
                out.println();

                // static initializer to register with Json facade
                out.println("    static {");
                out.println("        Json.registerAdapter(" + recordSimpleName + ".class, " + adapterSimpleName + "::toJson, " + adapterSimpleName + "::fromJson);");
                out.println("    }");
                out.println();

                // ensure class is loaded
                out.println("    static void ensureRegistered() {}");
                out.println();

                // --- toJson ---
                out.println("    static String toJson(" + recordSimpleName + " obj) {");
                out.println("        if (obj == null) return \"null\";");
                out.println("        StringBuilder sb = new StringBuilder();");
                out.println("        sb.append('{');");

                for (int i = 0; i < components.size(); i++) {
                    RecordComponentElement comp = components.get(i);
                    String fieldName = comp.getSimpleName().toString();
                    TypeMirror fieldType = comp.asType();

                    if (i > 0) {
                        out.println("        sb.append(',');");
                    }
                    out.println("        JsonWriter.writeString(\"" + fieldName + "\", sb);");
                    out.println("        sb.append(':');");
                    generateWriteField(out, fieldName, fieldType, recordSimpleName);
                }

                out.println("        sb.append('}');");
                out.println("        return sb.toString();");
                out.println("    }");
                out.println();

                // --- fromJson ---
                out.println("    static " + recordSimpleName + " fromJson(JsonValue value) {");
                out.println("        if (value instanceof JsonValue.JsonNull) return null;");
                out.println("        JsonValue.JsonObject obj = (JsonValue.JsonObject) value;");

                for (RecordComponentElement comp : components) {
                    String fieldName = comp.getSimpleName().toString();
                    TypeMirror fieldType = comp.asType();
                    generateReadField(out, fieldName, fieldType);
                }

                out.print("        return new " + recordSimpleName + "(");
                for (int i = 0; i < components.size(); i++) {
                    if (i > 0) out.print(", ");
                    out.print(components.get(i).getSimpleName().toString());
                }
                out.println(");");
                out.println("    }");

                out.println("}");
            }
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                    "Failed to generate adapter for " + recordSimpleName + ": " + e.getMessage(), recordElement);
        }
    }

    private void generateWriteField(PrintWriter out, String fieldName, TypeMirror type, String recordName) {
        String accessor = "obj." + fieldName + "()";
        TypeKind kind = type.getKind();

        switch (kind) {
            case INT -> out.println("        JsonWriter.writeInt(" + accessor + ", sb);");
            case LONG -> out.println("        JsonWriter.writeLong(" + accessor + ", sb);");
            case DOUBLE -> out.println("        JsonWriter.writeDouble(" + accessor + ", sb);");
            case FLOAT -> out.println("        JsonWriter.writeFloat(" + accessor + ", sb);");
            case BOOLEAN -> out.println("        JsonWriter.writeBoolean(" + accessor + ", sb);");
            case DECLARED -> generateWriteDeclaredField(out, accessor, (DeclaredType) type);
            default -> processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                    "Unsupported field type: " + type + " for field " + fieldName);
        }
    }

    private void generateWriteDeclaredField(PrintWriter out, String accessor, DeclaredType type) {
        String typeName = ((TypeElement) type.asElement()).getQualifiedName().toString();

        switch (typeName) {
            case "java.lang.String" -> out.println("        JsonWriter.writeString(" + accessor + ", sb);");
            case "java.lang.Integer" -> out.println("        JsonWriter.writeInteger(" + accessor + ", sb);");
            case "java.lang.Long" -> out.println("        JsonWriter.writeLongBoxed(" + accessor + ", sb);");
            case "java.lang.Double" -> out.println("        JsonWriter.writeDoubleBoxed(" + accessor + ", sb);");
            case "java.lang.Float" -> out.println("        JsonWriter.writeFloatBoxed(" + accessor + ", sb);");
            case "java.lang.Boolean" -> out.println("        JsonWriter.writeBooleanBoxed(" + accessor + ", sb);");
            case "java.math.BigDecimal" -> out.println("        JsonWriter.writeBigDecimal(" + accessor + ", sb);");
            case "java.math.BigInteger" -> out.println("        JsonWriter.writeBigInteger(" + accessor + ", sb);");
            case "java.util.List" -> {
                if (type.getTypeArguments().isEmpty()) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "Raw List type not supported, use List<T>");
                    return;
                }
                TypeMirror elementType = type.getTypeArguments().getFirst();
                String elementWriter = getElementWriterLambda(elementType);
                out.println("        JsonWriter.writeList(" + accessor + ", sb, " + elementWriter + ");");
            }
            case "java.util.Map" -> {
                if (type.getTypeArguments().size() < 2) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "Raw Map type not supported, use Map<String, V>");
                    return;
                }
                TypeMirror valueType = type.getTypeArguments().get(1);
                String valueWriter = getElementWriterLambda(valueType);
                out.println("        JsonWriter.writeMap(" + accessor + ", sb, " + valueWriter + ");");
            }
            default -> {
                // Check if it's an enum
                TypeElement typeElement = (TypeElement) type.asElement();
                if (isEnum(typeElement)) {
                    out.println("        JsonWriter.writeEnum(" + accessor + ", sb);");
                } else if (isAnnotatedJsonRecord(typeElement)) {
                    // Nested @JsonRecord — delegate to its adapter
                    String adapterName = typeElement.getSimpleName().toString() + "JsonAdapter";
                    out.println("        if (" + accessor + " == null) { sb.append(\"null\"); } else { sb.append(" + adapterName + ".toJson(" + accessor + ")); }");
                } else {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "Unsupported type: " + typeName);
                }
            }
        }
    }

    private String getElementWriterLambda(TypeMirror type) {
        if (type.getKind() == TypeKind.DECLARED) {
            DeclaredType dt = (DeclaredType) type;
            String name = ((TypeElement) dt.asElement()).getQualifiedName().toString();
            return switch (name) {
                case "java.lang.String" -> "JsonWriter::writeString";
                case "java.lang.Integer" -> "JsonWriter::writeInteger";
                case "java.lang.Long" -> "JsonWriter::writeLongBoxed";
                case "java.lang.Double" -> "JsonWriter::writeDoubleBoxed";
                case "java.lang.Float" -> "JsonWriter::writeFloatBoxed";
                case "java.lang.Boolean" -> "JsonWriter::writeBooleanBoxed";
                case "java.math.BigDecimal" -> "JsonWriter::writeBigDecimal";
                case "java.math.BigInteger" -> "JsonWriter::writeBigInteger";
                default -> {
                    TypeElement te = (TypeElement) dt.asElement();
                    if (isEnum(te)) {
                        yield "JsonWriter::writeEnum";
                    } else if (isAnnotatedJsonRecord(te)) {
                        String adapterName = te.getSimpleName().toString() + "JsonAdapter";
                        yield "(v, s) -> { if (v == null) { s.append(\"null\"); } else { s.append(" + adapterName + ".toJson(v)); } }";
                    } else {
                        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                "Unsupported list/map element type: " + name);
                        yield "null";
                    }
                }
            };
        }
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                "Unsupported list/map element type: " + type);
        return "null";
    }

    private void generateReadField(PrintWriter out, String fieldName, TypeMirror type) {
        String getValue = "obj.members().get(\"" + fieldName + "\")";
        TypeKind kind = type.getKind();

        switch (kind) {
            case INT -> out.println("        int " + fieldName + " = JsonMapper.toInt(" + getValue + ");");
            case LONG -> out.println("        long " + fieldName + " = JsonMapper.toLong(" + getValue + ");");
            case DOUBLE -> out.println("        double " + fieldName + " = JsonMapper.toDouble(" + getValue + ");");
            case FLOAT -> out.println("        float " + fieldName + " = JsonMapper.toFloat(" + getValue + ");");
            case BOOLEAN -> out.println("        boolean " + fieldName + " = JsonMapper.toBoolean(" + getValue + ");");
            case DECLARED -> generateReadDeclaredField(out, fieldName, (DeclaredType) type, getValue);
            default -> processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                    "Unsupported field type: " + type + " for field " + fieldName);
        }
    }

    private void generateReadDeclaredField(PrintWriter out, String fieldName, DeclaredType type, String getValue) {
        String typeName = ((TypeElement) type.asElement()).getQualifiedName().toString();

        switch (typeName) {
            case "java.lang.String" -> out.println("        String " + fieldName + " = JsonMapper.toString(" + getValue + ");");
            case "java.lang.Integer" -> out.println("        Integer " + fieldName + " = JsonMapper.toIntegerBoxed(" + getValue + ");");
            case "java.lang.Long" -> out.println("        Long " + fieldName + " = JsonMapper.toLongBoxed(" + getValue + ");");
            case "java.lang.Double" -> out.println("        Double " + fieldName + " = JsonMapper.toDoubleBoxed(" + getValue + ");");
            case "java.lang.Float" -> out.println("        Float " + fieldName + " = JsonMapper.toFloatBoxed(" + getValue + ");");
            case "java.lang.Boolean" -> out.println("        Boolean " + fieldName + " = JsonMapper.toBooleanBoxed(" + getValue + ");");
            case "java.math.BigDecimal" -> out.println("        java.math.BigDecimal " + fieldName + " = JsonMapper.toBigDecimal(" + getValue + ");");
            case "java.math.BigInteger" -> out.println("        java.math.BigInteger " + fieldName + " = JsonMapper.toBigInteger(" + getValue + ");");
            case "java.util.List" -> {
                if (type.getTypeArguments().isEmpty()) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "Raw List type not supported, use List<T>");
                    return;
                }
                TypeMirror elementType = type.getTypeArguments().getFirst();
                String elementMapper = getElementMapperLambda(elementType);
                String typeDecl = "java.util.List<" + getTypeString(elementType) + ">";
                out.println("        " + typeDecl + " " + fieldName + " = JsonMapper.toList(" + getValue + ", " + elementMapper + ");");
            }
            case "java.util.Map" -> {
                if (type.getTypeArguments().size() < 2) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "Raw Map type not supported, use Map<String, V>");
                    return;
                }
                TypeMirror valueType = type.getTypeArguments().get(1);
                String valueMapper = getElementMapperLambda(valueType);
                String typeDecl = "java.util.Map<String, " + getTypeString(valueType) + ">";
                out.println("        " + typeDecl + " " + fieldName + " = JsonMapper.toMap(" + getValue + ", " + valueMapper + ");");
            }
            default -> {
                TypeElement typeElement = (TypeElement) type.asElement();
                if (isEnum(typeElement)) {
                    out.println("        " + typeName + " " + fieldName + " = JsonMapper.toEnum(" + getValue + ", " + typeName + ".class);");
                } else if (isAnnotatedJsonRecord(typeElement)) {
                    String adapterName = typeElement.getSimpleName().toString() + "JsonAdapter";
                    out.println("        " + typeName + " " + fieldName + " = " + adapterName + ".fromJson(" + getValue + ");");
                } else {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "Unsupported type: " + typeName + " for field " + fieldName);
                }
            }
        }
    }

    private String getElementMapperLambda(TypeMirror type) {
        if (type.getKind() == TypeKind.DECLARED) {
            DeclaredType dt = (DeclaredType) type;
            String name = ((TypeElement) dt.asElement()).getQualifiedName().toString();
            return switch (name) {
                case "java.lang.String" -> "JsonMapper::toString";
                case "java.lang.Integer" -> "JsonMapper::toIntegerBoxed";
                case "java.lang.Long" -> "JsonMapper::toLongBoxed";
                case "java.lang.Double" -> "JsonMapper::toDoubleBoxed";
                case "java.lang.Float" -> "JsonMapper::toFloatBoxed";
                case "java.lang.Boolean" -> "JsonMapper::toBooleanBoxed";
                case "java.math.BigDecimal" -> "JsonMapper::toBigDecimal";
                case "java.math.BigInteger" -> "JsonMapper::toBigInteger";
                default -> {
                    TypeElement te = (TypeElement) dt.asElement();
                    if (isEnum(te)) {
                        yield "v -> JsonMapper.toEnum(v, " + name + ".class)";
                    } else if (isAnnotatedJsonRecord(te)) {
                        String adapterName = te.getSimpleName().toString() + "JsonAdapter";
                        yield adapterName + "::fromJson";
                    } else {
                        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                "Unsupported list/map element type: " + name);
                        yield "null";
                    }
                }
            };
        }
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                "Unsupported list/map element type: " + type);
        return "null";
    }

    private String getTypeString(TypeMirror type) {
        if (type.getKind() == TypeKind.DECLARED) {
            DeclaredType dt = (DeclaredType) type;
            return ((TypeElement) dt.asElement()).getQualifiedName().toString();
        }
        return type.toString();
    }

    private boolean isEnum(TypeElement element) {
        return element.getSuperclass() != null
                && element.getSuperclass().toString().startsWith("java.lang.Enum");
    }

    private boolean isAnnotatedJsonRecord(TypeElement element) {
        return element.getAnnotation(JsonRecord.class) != null;
    }

    private void generateRegistry() {
        try {
            // Determine a common package or use the first adapter's package
            String registryPackage = "";
            if (!adapterClassNames.isEmpty()) {
                String first = adapterClassNames.getFirst();
                int lastDot = first.lastIndexOf('.');
                if (lastDot > 0) {
                    registryPackage = first.substring(0, lastDot);
                }
            }

            String registryQualifiedName = registryPackage.isEmpty()
                    ? "JsonAdapterRegistry"
                    : registryPackage + ".JsonAdapterRegistry";

            JavaFileObject file = processingEnv.getFiler().createSourceFile(registryQualifiedName);
            try (var out = new PrintWriter(file.openWriter())) {
                if (!registryPackage.isEmpty()) {
                    out.println("package " + registryPackage + ";");
                    out.println();
                }
                out.println("/**");
                out.println(" * Generated registry — triggers class loading of all JSON adapters.");
                out.println(" * Call {@code JsonAdapterRegistry.initialize()} once at application startup.");
                out.println(" */");
                out.println("public final class JsonAdapterRegistry {");
                out.println();
                out.println("    private JsonAdapterRegistry() {}");
                out.println();
                out.println("    public static void initialize() {");
                for (String adapterClassName : adapterClassNames) {
                    String simpleName = adapterClassName.substring(adapterClassName.lastIndexOf('.') + 1);
                    out.println("        " + simpleName + ".ensureRegistered();");
                }
                out.println("    }");
                out.println("}");
            }
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                    "Failed to generate JsonAdapterRegistry: " + e.getMessage());
        }
    }
}
